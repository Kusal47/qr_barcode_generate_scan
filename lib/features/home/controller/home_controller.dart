import 'dart:developer';
import 'dart:io';

import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/cupertino.dart';
import 'package:get/get.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import 'package:pull_to_refresh/pull_to_refresh.dart';
import 'package:scan_qr/core/resources/export_resources.dart';
import 'package:scan_qr/features/qr_scan/model/qr_scan_model.dart';
import 'package:share_plus/share_plus.dart';

import '../../../core/widgets/export_custom_widget.dart';

class HomeController extends GetxController {
  String platformVersion = 'Unknown';
  int? visibleIndex;
  final SecureStorageService secureStorageService = SecureStorageService();
  final RefreshController refreshController = RefreshController();
  @override
  void onInit() {
    super.onInit();
    getDeviceInfo();
    fetchWifiHistory();
    fetchUrlHistory();
    fetchContactInfoHistory();
  }

  Future<void> getDeviceInfo() async {
    DeviceInfoPlugin deviceInfo = DeviceInfoPlugin();

    if (Platform.isAndroid) {
      AndroidDeviceInfo androidInfo = await deviceInfo.androidInfo;
      platformVersion = androidInfo.model;
    } else {
      IosDeviceInfo iosInfo = await deviceInfo.iosInfo;
      platformVersion = iosInfo.utsname.machine;
    }
    update();
  }

  void changeVisibility(int index) {
    if (visibleIndex == index) {
      visibleIndex = null; // hide if already visible
    } else {
      visibleIndex = index; // show this one, hide others
    }
    update();
  }

  List<WifiModel> wifiHistory = [];
  List<WiFi> wifiList = [];
  fetchWifiHistory() async {
    try {
      final wifiData = await secureStorageService.getWifiData();
      if (wifiData != null && wifiData.isNotEmpty) {
        for (var i in wifiData) {
          final WiFi data = WiFi(
            ssid: i.ssid,
            password: i.password,
            encryptionType: i.encryptionType,
          );
          wifiList.add(data);
        }
        final uniqueWifiLists = {for (var val in wifiList) val.ssid: val}.values.toList();
        wifiHistory = uniqueWifiLists.map((e) => WifiModel.fromJson(e)).toList().reversed.toList();
      } else {
        wifiHistory = [];
      }
    } catch (e) {
      log("Error while decoding data: $e");
      wifiHistory = [];
    }
    update();
  }

  List<UrlModel> urlHistory = [];
  List<UrlBookmark> urlList = [];
  fetchUrlHistory() async {
    try {
      final urlData = await secureStorageService.getUrlData();
      if (urlData != null && urlData.isNotEmpty) {
        for (var i in urlData) {
          final UrlBookmark data = UrlBookmark(url: i.url, title: i.title);
          urlList.add(data);
        }
        final uniqueUrlLists = {for (var val in urlList) val.url: val}.values.toList();
        urlHistory = uniqueUrlLists.map((e) => UrlModel.fromJson(e)).toList().reversed.toList();
      } else {
        urlHistory = [];
      }
    } catch (e) {
      log("Error while decoding data: $e");
      urlHistory = [];
    }
    update();
  }

  List<ContactInfoModel> contactHistory = [];
  List<ContactInfo> contactList = [];
  fetchContactInfoHistory() async {
    try {
      final contactInfoData = await secureStorageService.getContactInfoData();
      log("contactInfoData: $contactInfoData");
      if (contactInfoData != null && contactInfoData.isNotEmpty) {
        for (var e in contactInfoData) {
          final ContactInfo data = ContactInfo(
            name: PersonName(formattedName: e.name!.formattedName),
            phones: [Phone(number: e.phones[0].number)],
            emails: [Email(address: e.emails[0].address)],
            addresses: [Address(addressLines: e.addresses[0].addressLines)],
          );
          contactList.add(data);
        }
        final uniqueContactLists =
            {for (var val in contactList) val.phones[0].number: val}.values.toList();
        contactHistory =
            uniqueContactLists.map((e) => ContactInfoModel.fromJson(e)).toList().reversed.toList();
      } else {
        contactHistory = [];
      }
    } catch (e) {
      log("Error while decoding data: $e");
      contactHistory = [];
    }
    update();
  }

  deleteQRData({String? ssid, String? url, bool all = false, String? contactNumber}) async {
    all == true
        ? await secureStorageService.deleteQrData()
        : await secureStorageService.deleteIndividualQrData(
          ssid: ssid,
          url: url,
          contactNumber: contactNumber,
        );
    fetchWifiHistory();
    fetchUrlHistory();
    fetchContactInfoHistory();
    update();
  }

  GlobalKey qrKey = GlobalKey();
  Future<void> shareQr(GlobalKey qrkey, {String? text}) async {
    final filePath = await shareQrFromBytes(qrkey);
    await shareFunction(
      text: text ?? 'Shared from ScanQR',
      subject: 'QR code generated by ScanQR',
      thummbnailPath: XFile(filePath),
      files: [XFile(filePath)],
    );
  }

  //  Future<void> shareQr(GlobalKey qrKey, {String? text}) async {
  //   final qrBytes = await captureWidgetAsImage(qrKey);
  //   await printPDF(qrBytes);

  //   // final data = ShareParams(text: text ?? 'Shared from ScanQR', files: [XFile(pdfPath)]);
  //   // await SharePlus.instance.share(data);
  // }

  // Future<void> printPDF(Uint8List qrBytes) async {
  //   final pdfBytes = await generatePdfFromImage(qrBytes);

  //   await Printing.layoutPdf(
  //     format: PdfPageFormat.a3,
  //     name: 'ScanQR.pdf',
  //     onLayout: (PdfPageFormat format) async {
  //       return pdfBytes;
  //     },
  //   );
  // }
}
